// TODO[5]:

#[cfg(feature = "probability_distributions")]
mod scipy_numerical_stability_tests {

    // // AUTO-GENERATED FILE. DO NOT EDIT BY HAND.
    // // Generated from SciPy 1.16.1 on 2025-08-21T22:25:23Z.
    // // Distribution: Beta
    // //
    // // This file is created by gen_scipy_tests.py and contains reference
    // // tests whose expected values are produced by SciPy at generation time.
    // //

    // // Each test compares our kernel outputs against SciPy with a per-test tolerance.
    // // NaN/Inf equality is handled by util::assert_slice_close.

    // mod util;
    // use super::util::assert_slice_close;

    // use minarrow::vec64;

    // // ---- Continuous distributions (logcdf / sf / isf) ----
    // // use simd_kernels::kernels::scientific::distributions::univariate::normal::{normal_logcdf, normal_sf, normal_isf};
    // // use simd_kernels::kernels::scientific::distributions::univariate::exponential::{exponential_logcdf, exponential_sf, exponential_isf};
    // // use simd_kernels::kernels::scientific::distributions::univariate::chi2::{chi2_logcdf, chi2_sf, chi2_isf};
    // // use simd_kernels::kernels::scientific::distributions::univariate::gamma::{gamma_logcdf, gamma_sf, gamma_isf};
    // // use simd_kernels::kernels::scientific::distributions::univariate::beta::{beta_logcdf, beta_sf, beta_isf};
    // //
    // // ---- Discrete distributions (logpmf) ----
    // // use simd_kernels::kernels::scientific::distributions::univariate::poisson::poisson_logpmf;
    // // use simd_kernels::kernels::scientific::distributions::univariate::binomial::binomial_logpmf;
    // // use simd_kernels::kernels::scientific::distributions::univariate::neg_binomial::neg_binomial_logpmf;
    // // use simd_kernels::kernels::scientific::distributions::univariate::geometric::geometric_logpmf;

    // #[test]
    // fn normal_logcdf_extreme_tails() {
    //     let x = vec64![-10.0, -8.0, -6.0, -4.0, 4.0, 6.0, 8.0, 10.0];
    //     let expect = vec64![-53.231285150512477, -35.01343715991456, -20.73676894997471, -10.360101486527292, -3.1671743377489206e-05, -9.8658764552437208e-10, -6.2209605742717425e-16, -7.6198530241604696e-24];
    //     let got = normal_logcdf(&x, 0.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn normal_sf_survival_function() {
    //     let x = vec64![-10.0, -8.0, -6.0, -4.0, 4.0, 6.0, 8.0, 10.0];
    //     let expect = vec64![1.0, 0.99999999999999933, 0.9999999990134123, 0.99996832875816688, 3.1671241833119863e-05, 9.8658764503769458e-10, 6.2209605742717405e-16, 7.6198530241604696e-24];
    //     let got = normal_sf(&x, 0.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn normal_isf_inverse_survival() {
    //     let q = vec64![1.0000000000000001e-15, 9.9999999999999998e-13, 1e-10, 1e-08, 9.9999999999999995e-07, 0.0001, 0.01, 0.97999999999999998];
    //     let expect = vec64![7.9413453261709979, 7.0344838253011313, 6.3613409024040557, 5.6120012441747891, 4.7534243088228987, 3.7190164854556804, 2.3263478740408408, -2.0537489106318225];
    //     let got = normal_isf(&q, 0.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 9.9999999999999998e-13);
    // }

    // #[test]
    // fn exponential_logcdf_extreme_tails() {
    //     let x = vec64![0.10000000000000001, 1.0, 10.0, 20.0, 30.0];
    //     let expect = vec64![-2.3521684610440907, -0.45867514538708193, -4.5400960370489214e-05, -2.0611536245627349e-09, -9.3576229688406128e-14];
    //     let got = exponential_logcdf(&x, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn exponential_sf_survival_function() {
    //     let x = vec64![0.10000000000000001, 1.0, 10.0, 20.0, 30.0];
    //     let expect = vec64![0.90483741803595952, 0.36787944117144233, 4.5399929762484854e-05, 2.0611536224385579e-09, 9.3576229688401748e-14];
    //     let got = exponential_sf(&x, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn exponential_isf_inverse_survival() {
    //     let q = vec64![1.0000000000000001e-15, 9.9999999999999998e-13, 1e-10, 1e-08, 9.9999999999999995e-07, 0.0001, 0.01, 0.97999999999999998];
    //     let expect = vec64![34.538776394910684, 27.631021115928547, 23.025850929940457, 18.420680743952367, 13.815510557964274, 9.2103403719761818, 4.6051701859880909, 0.020202707317519466];
    //     let got = exponential_isf(&q, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 9.9999999999999998e-13);
    // }

    // #[test]
    // fn chi2_logcdf_extreme_tails() {
    //     let x = vec64![0.001, 0.10000000000000001, 1.0, 10.0, 20.0, 50.0];
    //     let expect = vec64![-3.6798356476917045, -1.3936398091732776, -0.38171514630212178, -0.0015666287802848448, -7.7442464176429679e-06, -1.5374597944292147e-12];
    //     let got = chi_logcdf(&x, 1, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn chi2_sf_survival_function() {
    //     let x = vec64![0.001, 0.10000000000000001, 1.0, 10.0, 20.0, 50.0];
    //     let expect = vec64![0.97477287936996038, 0.75182963404584924, 0.31731050786291115, 0.001565402258002549, 7.7442164310440875e-06, 1.5374597944280329e-12];
    //     let got = chi2_sf(&x, 1, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn chi2_isf_inverse_survival() {
    //     let q = vec64![1.0000000000000001e-15, 9.9999999999999998e-13, 1e-10, 1e-08, 9.9999999999999995e-07, 0.0001, 0.01, 0.97999999999999998];
    //     let expect = vec64![64.430463520123652, 50.844127911818155, 41.821456364761289, 32.841253361236788, 23.928126976934827, 15.136705226623397, 6.6348966010212171, 0.00062845016128367014];
    //     let got = chi2_isf(&q, 1, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 9.9999999999999998e-13);
    // }

    // #[test]
    // fn gamma_logcdf_extreme_tails() {
    //     let x = vec64![0.01, 0.5, 5.0, 15.0, 25.0];
    //     let expect = vec64![-9.9101514401912212, -2.4056813913603712, -0.041267595863406295, -4.8944491058257002e-06, -3.6108654055425644e-10];
    //     let got = gamma_logcdf(&x, 2.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn gamma_sf_survival_function() {
    //     let x = vec64![0.01, 0.5, 5.0, 15.0, 25.0];
    //     let expect = vec64![0.99995033208665973, 0.90979598956895014, 0.040427681994512792, 4.8944371280292168e-06, 3.6108654048906468e-10];
    //     let got = gamma_sf(&x, 2.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn gamma_isf_inverse_survival() {
    //     let q = vec64![1.0000000000000001e-15, 9.9999999999999998e-13, 1e-10, 1e-08, 9.9999999999999995e-07, 0.0001, 0.01, 0.97999999999999998];
    //     let expect = vec64![38.207648230599482, 31.099873195769149, 26.33398160553087, 21.535785245064289, 16.688420790859919, 11.756371222495419, 6.6383520679938126, 0.21469909500793458];
    //     let got = gamma_isf(&q, 2.0, 1.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 9.9999999999999998e-13);
    // }

    // #[test]
    // fn beta_logcdf_extreme_tails() {
    //     let x = vec64![1e-10, 9.9999999999999995e-07, 0.10000000000000001, 0.90000000000000002, 0.99999899999999997, 0.99999999989999999];
    //     let expect = vec64![-11.964508170243016, -7.3593378176048638, -1.5855614147303534, -0.2292028275811151, -0.00063682260696013536, -6.3662182514771019e-06];
    //     let got = beta_logcdf(&x, 0.5, 0.5, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn beta_sf_survival_function() {
    //     let x = vec64![1e-10, 9.9999999999999995e-07, 0.10000000000000001, 0.90000000000000002, 0.99999899999999997, 0.99999999989999999];
    //     let expect = vec64![0.99999363380227524, 0.99936338012152903, 0.79516723530086653, 0.20483276469913342, 0.00063661987848007769, 6.3661979871526918e-06];
    //     let got = beta_sf(&x, 0.5, 0.5, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn beta_isf_inverse_survival() {
    //     let q = vec64![1.0000000000000001e-15, 9.9999999999999998e-13, 1e-10, 1e-08, 9.9999999999999995e-07, 0.0001, 0.01, 0.97999999999999998];
    //     let expect = vec64![1.0, 1.0, 1.0, 0.99999999999999978, 0.99999999999753264, 0.99999997532598905, 0.9997532801828658, 0.00098663578586422073];
    //     let got = beta_isf(&q, 0.5, 0.5, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 9.9999999999999998e-13);
    // }

    // #[test]
    // fn poisson_logpmf_extreme_probs() {
    //     let k = vec64![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
    //     let expect = vec64![-0.001, -6.9087552789821371, -14.509657738524218, -22.516025306174466, -30.810074946276494, -39.327268137692727, -48.026782885902918, -56.88044831394037, -65.867645134602355, -74.972624990920707];
    //     let got = poisson_logpmf(&k, 0.001, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn poisson_logpmf_extreme_probs_2() {
    //     let k = vec64![20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0];
    //     let expect = vec64![-14.095156352190571, -13.22765578448584, -12.406675232416021, -11.630146442917017, -10.896177267836819, -10.203030087276865, -9.5491036198702091, -8.9329174804463776, -8.353098985193455, -7.8083718097517618, -7.2975461859857802, -6.8195103850427756, -6.373223282414358, -5.9577078384527198, -5.5720453576407039, -5.2153704137019616, -4.8868663467299598, -4.5857612539460035, -4.3113244082442606, -4.0628630489457436, -3.8397194976315632, -3.6412685589077114, -3.4669151717629205, -3.3160922820283503, -3.1882589105184707, -3.0828983948606776, -2.9995167859215712, -2.937641382203509, -2.8968193876832515, -2.8766166803657143, -2.8766166803657143, -2.8964193076619438, -2.9356400208152138, -2.9939089289391916, -3.0708699700753073, -3.1661801498796649, -3.2795088351866468, -3.4105370975930214, -3.5589571027113038, -3.7244715411888762, -3.9067930979828702, -4.1056439567280165, -4.3207553363449165, -4.5518670573083284, -4.7987271352398579, -5.0610913997073226, -5.3387231363056458, -5.6313927502684464, -5.9388774500164345, -6.2609609491855736, -6.5974331858066932, -6.948090057419904, -7.3127331710078636, -7.6911696067280673, -8.0832116945040582, -8.4886768026122184, -8.9073871374704368, -9.3391695538959993, -9.7838553751573727, -10.241280222196224];
    //     let got = poisson_logpmf(&k, 50.0, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn binomial_logpmf_extreme_probs() {
    //     let k = vec64![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
    //     let expect = vec64![-1.0005003335835334, -0.99949983324895519, -1.692647013810471, -2.7922608048142812, -4.180559174621532, -5.79300460811878, -7.5887761188369822, -9.5397038398847354, -11.625169496168528, -13.829425744867603];
    //     let got = binomial_logpmf(&k, 1000, 0.001, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn binomial_logpmf_extreme_probs_3() {
    //     let k = vec64![90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0];
    //     let expect = vec64![-16.473908724417402, -14.087063287805634, -11.816507437383876, -9.6745455387227146, -7.6768103218027619, -5.8438078940406228, -4.2035983229398468, -2.7968950901887535, -1.6881304300565905, -0.99498324949666239, -1.0050335853501451];
    //     let got = binomial_logpmf(&k, 100, 0.98999999999999999, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn neg_binomial_logpmf_extreme_probs() {
    //     let k = vec64![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0];
    //     let expect = vec64![-34.538776394910684, -32.930338982810163, -31.832727194475641, -30.986429834422019, -30.294283154195661, -29.707496989627124, -29.197671866194717, -28.746687242785242, -28.342222635010661, -27.975498355218932, -27.640026618931294, -27.330872190961042, -27.04419061884284, -26.776927132581747, -26.52661320463443, -26.29122492690378, -26.069081875923157, -25.858773282589532, -25.659103087460959, -25.469048351031834];
    //     let got = neg_binomial_logpmf(&k, 5, 0.001, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }

    // #[test]
    // fn geometric_logpmf_extreme_probs() {
    //     let k = vec64![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0];
    //     let expect = vec64![-6.9077552789821368, -6.9087557793157206, -6.9097562796493035, -6.9107567799828873, -6.9117572803164711, -6.9127577806500549, -6.9137582809836378, -6.9147587813172215, -6.9157592816508053, -6.9167597819843882, -6.917760282317972, -6.9187607826515558, -6.9197612829851396, -6.9207617833187225, -6.9217622836523063, -6.9227627839858901, -6.923763284319473, -6.9247637846530568, -6.9257642849866405];
    //     let got = geometric_logpmf(&k, 0.001, None, None).unwrap();
    //     assert_slice_close(&got, &expect, 1.0000000000000001e-15);
    // }
}
